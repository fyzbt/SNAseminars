---
title: "Job"
output: html_document
---

```{r echo=FALSE, message=FALSE, warning=FALSE}
#uploading data
library(igraph)
library(ggraph)
library(readr)
library(dplyr)
library(ggplot2)
options(scipen = 999)


job = read.csv("/Users/macbook/Downloads/SPbsoc-network-Job x Job.csv", row.names=1) 
attributes = read.csv("/Users/macbook/Downloads/Attributes.csv")
job = as.matrix(job)

library(RColorBrewer)
coul9 = brewer.pal(9, "Set1")
unis = c("ЕУ","цнси",'вшэ',"социологический институт ран","СПбГУ","НИИ КСИ","Герцена", "кафедры в других вузах", 'другое')
```

```{r}
job.g <- graph.adjacency(job,mode="directed", weighted=NULL, diag=T)
V(job.g)$Degree = igraph::degree(job.g)
V(job.g)$Closeness = igraph::closeness(job.g)
V(job.g)$Betwenness = igraph::betweenness(job.g)
library(info.centrality)
V(job.g)$Info = info.centrality.vertex(job.g)

V(job.g)$atr = attributes$affiliation

job.g = delete.vertices(job.g, V(job.g)[degree(job.g) == 0])
my_color1=coul9[as.numeric(as.factor(V(job.g)$atr))]


l = layout_nicely(job.g)
set.seed(111)
plot(job.g,
     vertex.label=NA,
     vertex.label.font=1,vertex.label.dist=1,
     edge.width=0.7,edge.arrow.size=0.3, vertex.color=my_color1, layout=l, edge.length=1, vertex.size=5)

#legend("bottomleft", 
 # legend = unis, 
  #col = coul9,
  #bty = "n", pch=20 , pt.cex = 3, cex = 1.5, text.col=coul , horiz = FALSE, inset = c(0.1, 0.1))
 

```


```{r echo=FALSE, warning=FALSE}
ptable = as.data.frame(cbind(info.centrality.vertex(job.g), degree(job.g), closeness(job.g), betweenness(job.g), round(evcent(job.g)$vector, 3)))
titles = c('Info',"Degree", "Closeness", "Betweenness", "Eigenvector")
colnames(ptable) = titles

ptable$names = rownames(ptable)
ptable$ID = ptable$names
ptable = left_join(ptable, attributes, by="ID")
```

##Degree centrality

Для начала выявим, кто в сети подписчиков важнее по признаку "у кого больше друзей" (чем больше связей, тем лучше). Такой показатель называется **степенью (degree)**. 

(Помним, что в данный момент наши данные содержат узлы с дегри предварительно отфильтрованы)

Нарисуем график, показывающий то, как распределяется наш дегри среди узлов в сети.
Очевидно, что больше всего узлов с минимальным значением дегри. 

```{r echo=FALSE, warning=FALSE}
Degree = ptable%>% group_by(Degree) %>% tally()
Degree = as.data.frame(Degree)
head(Degree)
tail(Degree)
```


```{r echo=FALSE, warning=FALSE}
library(ggplot2)
ggplot()+
  geom_density(data=ptable, aes(x=Degree, fill=UnivLocal), alpha = 0.1) + theme_minimal() + xlab("Degree") + ylab("Proportion") + ggtitle("Degree centrality")
```


```{r echo=FALSE, warning=FALSE}


set.seed(250)
plot(job.g,
     vertex.label=NA,
     vertex.label.font=1,vertex.label.dist=1,
     edge.width=0.7,edge.arrow.size=0.3, vertex.color=my_color1, layout=l, edge.length=1, vertex.size=abs(V(job.g)$Degree))
 
```


##Closeness centrality

Если нам интересны вершины с наиболее короткими путями до остальных (т.е. наиболее близкие к остальным), то рассматривается **центральность по близости (closeness)**. 
```{r echo=FALSE, warning=FALSE}
Closeness = ptable %>% group_by(Closeness) %>% tally()
Closeness = as.data.frame(Closeness)
head(Closeness)
tail(Closeness)
```

```{r echo=FALSE, warning=FALSE}
ptable$gender = as.factor(ptable$gender)
ggplot()+
  geom_histogram(data=ptable, aes(x=Closeness, fill=gender), binwidth = 0.000001) + theme_minimal() + xlab("Closeness") + ylab("Number") + ggtitle("Closeness centrality")
```

```{r echo=FALSE, warning=FALSE}
V(df.g)$Closeness = igraph::closeness(df.g)

#Попытаемся раскрасить график 
# Сделаем палетку из 5 цветов
library(RColorBrewer)
coul5 = brewer.pal(2, "Set1")

# Создадим цветовой вектор
my_color1=coul[as.numeric(as.factor(V(df.g)$Gender))]

#рисуем раскрашенную сеть
set.seed(250)
plot(job.g,
     vertex.label=NA,
     vertex.label.font=1,vertex.label.dist=1,
     edge.width=0.7,edge.arrow.size=0.3, vertex.color=my_color1, layout=l, edge.length=1, 
vertex.size=abs(V(job.g)$Closeness)*900000, mode="directed")

```


```{r echo=FALSE, warning=FALSE}

set.seed(250)
plot(job.g,
     vertex.label=NA,
     vertex.label.font=1,vertex.label.dist=1,
     edge.width=0.7,edge.arrow.size=0.3, vertex.color=my_color1, layout=l, edge.length=1, vertex.size=abs(V(job.g)$Info)*100)
 
```

```{r echo=FALSE, warning=FALSE}

set.seed(250)
plot(job.g,
     vertex.label=NA,
     vertex.label.font=1,vertex.label.dist=1,
     edge.width=0.7,edge.arrow.size=0.3, vertex.color=my_color1, layout=l, edge.length=1, vertex.size=abs(V(job.g)$Betweenness)+1)
 
```


```{r}
summary(V(df.g)$Info)
summary(V(df.g)$Centrality)
summary(V(df.g)$Degree)

```

#Меры централизации

##Degree Centralization

Метрика для сети и для идеальной сети: 

```{r echo=FALSE, warning=FALSE}
degr_cent = centr_degree(job.g, mode = "total", loops = TRUE, normalized = TRUE)
degr_cent$centralization # получаем значение для сети
degr_cent$theoretical_max # значение для идеальной сети с таким же кол-вом узлов и ребер
```

##Information Centralization

Метрика для сети:

```{r echo=FALSE, warning=FALSE}
library(info.centrality)
info_cent = info.centrality.vertex(job.g)
centralize(info_cent, normalized = FALSE)
```

##Closeness Centralization

Метрика для сети и для идеальной сети: 

```{r echo=FALSE, warning=FALSE}
close_cent = centralization.closeness(job.g, mode = "total", normalized = TRUE)
close_cent$centralization
close_cent$theoretical_max
```


##Betweenness Centralization

Метрика для сети и для идеальной сети: 

```{r echo=FALSE, warning=FALSE}
node_cent = centralization.betweenness(job.g)
node_cent$centralization
node_cent$theoretical_max
```


##Edge betweenness Centralization

Метрика для сети: 

```{r echo=FALSE, warning=FALSE}
edge_btw = edge_betweenness(job.g, e = E(job.g), directed = FALSE, weights = NULL)
edge_cent = centralize(edge_btw, normalized = FALSE)
edge_cent # не нормализованные значения
```


```{r}
library(dplyr)
ptable$Degree = as.numeric(as.character(ptable$Degree))
ptable %>% 
  select(ID, Closeness, gender, liberalism2, affiliation) %>% 
  arrange(desc(Closeness))


```

```{r}
ptable$Closeness = as.numeric(as.character(ptable$Closeness))
ptable %>% 
  arrange(Closeness)
```

```{r echo=FALSE, warning=FALSE}
transitivity(job.g, type="global")
```

```{r echo=FALSE, warning=FALSE}
local_transit = transitivity(gang, type="local")
V(job.g)$transit = local_transit
ggraph(job.g, layout = "fr") +
  geom_edge_link(width=0.3, show.legend = FALSE) +
  geom_node_point(aes(size=transit*10), alpha = 0.7) +
  theme_void() +
  theme(legend.position="none", text=element_text(family="Times New Roman"))
```

```{r echo=FALSE, warning=FALSE}
transitivity(job.g, type="undirected")
```

```{r echo=FALSE, warning=FALSE}
transitivity(job.g, type="barrat")
```


# Clustering coefficient
```{r}
install.packages("NetworkToolbox")
library(NetworkToolbox)
cl_coeff <- clustcoeff(job.g, weighted = FALSE)
```
Global clustering coefficient
```{r}
cl_coeff$CC
```
Local clustering coefficient
```{r}
cl_coeff$CCi
cl_coeff_CCi <- as.data.frame(cl_coeff$CCi) %>% mutate(name=rownames(cl_coeff_CCi)) 
colnames(cl_coeff_CCi)[1] <- "coeff"
cl_coeff_CCi <- cl_coeff_CCi %>% select(name, coeff)
```

table(ptable)
```{r}
table(ptable$WeGrants2)
```
